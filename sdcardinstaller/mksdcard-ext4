#!/bin/bash
#
# Copyright (c) 2013,2014,2017 Imagination Technologies
# Original-Author: Paul Burton <paul.burton@imgtec.com>
#
# Writes u-boot and Android filesystems to the sd card.
# Derived from the Debian setup script by Paul Burton
#
# Usage:
#   ./mksdcard-ext4 /dev/sdX
#

set -e

cleanup()
{
  echo "Cleaning up..."
  [ -z "${sdMount}" ] || sudo umount ${sdMount}
  rm -rf ${tmpDir}
  rm -rf ${verifyDir}
  [ "${finished}" = "true" ] && sudo eject ${device} && echo "Cleanup completed; it is safe to remove your card"
  trap - EXIT INT TERM
}
trap cleanup EXIT INT TERM

die()
{
  echo "$@" >&2
  exit 1
}

sfdisk_ci20()
{
  sfdisk_tool=`which sfdisk`
  blockdev_tool=`which blockdev`
  partprobe_tool=`which partprobe`

  [ -f "$sfdisk_tool" ] || die "No sfdisk in \$PATH"
  [ -f "$blockdev_tool" ] || die "No blockdev in \$PATH"
  [ -f "$partprobe_tool" ] || die "No partprobe in \$PATH"
  [ -b "$1" ] || die "Device '$1' not found"

  sfdisk_version=`$sfdisk_tool --version | sed 's,.*2\.\([0-9]*\)\.[0-9]*,\1,'`

  unset sfdisk_is_ancient
  test $sfdisk_version -lt 26 && sfdisk_is_ancient=1

  sfdisk_dev="$1"
  shift

  sfdisk_parts=`echo $* | tr ' ' '\n'`

  set +e
  if [ $sfdisk_is_ancient ]; then
      echo "$sfdisk_parts" | tr -d M | sudo $sfdisk_tool -L -uM "$sfdisk_dev"
  else
      echo "$sfdisk_parts" | sudo $sfdisk_tool "$sfdisk_dev"
  fi
  set -e

  sudo $blockdev_tool --rereadpt $sfdisk_dev
  sudo $partprobe_tool -d $sfdisk_dev
  sleep 2
}

init_core()
{
  readonly tmpDir=`mktemp -d`
  readonly verifyDir=`mktemp -d`
  readonly ubootPrebuiltDir="$ANDROID_BUILD_TOP/device/imgtec/ci20/u-boot"
  #check for U-Boot prebuilt dir
  [ ! -z "${ANDROID_BUILD_TOP}" ] || die "ANDROID_BUILD_TOP has not been initialized"
  [ -e "${ubootPrebuiltDir}" ] || die "U-Boot prebuilt directory '${ubootPrebuiltDir}' does not exist"

  readonly device="$1"
  # check device
  [ -e "${device}" ] || die "Device '${device}' not found"
  grep ${device} /etc/mtab >/dev/null && \
  die "Device '${device}' contains mounted partitions"

  # Check for awk
  [ -z `which awk 2>&1` ] && die "No 'awk' present"

  # Check for md5sum
  [ -z `which md5sum 2>&1` ] && die "No 'md5sum' present"

  # Check for mkfs.ext4
  [ -z `which mkfs.ext4 2>&1` ] && die "No 'mkfs.ext4' present"

  # Check for mkfs.f2fs
  [ -z `which mkfs.f2fs 2>&1` ] && die "No 'mkfs.f2fs' present"

  # Check for stat
  [ -z `which stat 2>&1` ] && die "No 'stat' present"

  return 0
}

init_partition_layout_constants()
{
  partitions=("boot" "system" "vendor" "extended" "cache" "userdata")
  readonly partNum=${#partitions[@]}

  # Partition sizes and offsets represent size in MB
  local bootPartSize=30
  local cachePartSize=256
  local dataPartSize=2048
  local vendorPartSize=64
  local extendedPartPadding=1

  local systemImgSize=`stat -c %s ${systemImg}`
  local megabyte=$((1024 * 1024))
  local systemPartSize=$((${systemImgSize} / megabyte))

  local extPartSize=$((2 * ${extendedPartPadding} + ${cachePartSize} + ${dataPartSize}))

  # 2M is skipped and used for storing U-Boot outside the visible partition layout
  readonly bootPartOffset="2"
  readonly systemPartOffset=$((${bootPartOffset} + ${bootPartSize}))
  readonly vendorPartOffset=$((${systemPartOffset} + ${systemPartSize}))
  readonly extPartOffset=$((${vendorPartOffset} + ${vendorPartSize}))
  readonly cachePartOffset=$((${extPartOffset} + ${extendedPartPadding}))
  readonly dataPartOffset=$((${cachePartOffset} + ${cachePartSize} + ${extendedPartPadding}))

  local tmpPartitionLayout="${bootPartOffset}M,${bootPartSize}M,83"
  tmpPartitionLayout="${tmpPartitionLayout} ${systemPartOffset}M,${systemPartSize}M,83"
  tmpPartitionLayout="${tmpPartitionLayout} ${vendorPartOffset}M,${vendorPartSize}M,83"
  tmpPartitionLayout="${tmpPartitionLayout} ${extPartOffset}M,${extPartSize}M,5"
  tmpPartitionLayout="${tmpPartitionLayout} ${cachePartOffset}M,${cachePartSize}M,83"
  tmpPartitionLayout="${tmpPartitionLayout} ${dataPartOffset}M,${dataPartSize}M,83"
  readonly partitionLayout=${tmpPartitionLayout}
}

init_image_constants()
{
  # check for Android images
  readonly bootImg=${BOOTIMG:-${OUT}/boot.img}
  [ -e "${bootImg}" ] || die "Android boot image '${bootImg}' not found"
  readonly recoveryImg=${RECOVERYIMG:-${OUT}/recovery.img}
  [ -e "${recoveryImg}" ] || die "Android recovery image '${recoveryImg}' not found"
  readonly systemImg=${SYSTEMIMG:-${OUT}/system.img}
  [ -e "${systemImg}" ] || die "Android system image '${systemImg}' not found"
  readonly vendorImg=${VENDORIMG:=${OUT}/vendor.img}
  [ -e "${vendorImg}" ] || die "Android vendor image '${vendorImg}' not found"

  readonly dtb=$ANDROID_BUILD_TOP/device/imgtec/ci20/dtb/ci20-sdcard.dtb
  [ -e "${dtb}" ] || die "Kernel device tree blob '${dtb}' not found"

  readonly envSize=$((32 * 1024))

  readonly bs_uBootSPL=512
  readonly seek_uBootSPL=1
  readonly bs_uBootImg=1024
  readonly seek_uBootImg=14
  readonly bs_uBootEnv=1
  readonly seek_uBootEnv=$((526 * 1024))

  readonly envText=${tmpDir}/u-boot-env.txt
  readonly envBin=${tmpDir}/u-boot-env.bin
}

init_uboot_env_constants()
{
  readonly mmcPart="mmc 0:1"
  readonly bootImgAddr=0x88000000
  readonly dtbAddr=0x87000000
  readonly baudRate=115200
  readonly stdioCfg="eserial0,eserial4"

  # Command to boot Android from MMC
  readonly androidInitCmd="ext4load ${mmcPart} ${bootImgAddr} boot.img; run dtbcmd; boota ${bootImgAddr}"
  # Command to set device specific MAC address
  readonly ethArgs='env set bootargs dm9000.mac_addr=${ethaddr}'
  # Command for loading device tree blob
  readonly dtbCmd="env set bootargs \""'${bootargs}'" dtb_addr=$dtbAddr\"; ext4load ${mmcPart} ${dtbAddr} jz4780.dtb;"
  # Command for filling blkdevpart bootarg
  readonly blkdevpartCmd='mmc part; env set bootargs ${bootargs} blkdevparts=mmcblk0:${blkdevparts}'
}

init_constants()
{
  init_image_constants
  init_partition_layout_constants
  init_uboot_env_constants
}

configure_sd_card_partitions()
{
  sfdisk_ci20 ${device} ${partitionLayout}

  for((i=1; i<=${partNum}; i++));
  do
    case ${partitions[$i-1]} in
      "boot")
        readonly partBoot="${device}${i}"
        sudo mkfs.ext4 -L "${partitions[$i-1]}" ${partBoot}
        ;;
      "system")
        readonly partSystem="${device}${i}"
        ;;
      "vendor")
        readonly partVendor="${device}${i}"
        ;;
      "cache")
        readonly partCache="${device}${i}"
        sudo mkfs.f2fs -l "${partitions[$i-1]}" ${partCache}
        ;;
      "userdata")
        readonly partUserdata="${device}${i}"
        sudo mkfs.f2fs -l "${partitions[$i-1]}" ${partUserdata}
        ;;
    esac
  done

  # sdMount is not initialized in init_constants()
  # the way it is used in the cleanup() function
  readonly sdMount=${tmpDir}/sd_mount
  mkdir ${sdMount}
  # mount ext4 partition
  sudo mount ${partBoot} ${sdMount}
  sudo chmod a+w ${sdMount}
}

burn_uboot_env()
{
  echo "ainitcmd=${androidInitCmd}" > ${envText}
  echo "baudrate=${baudRate}" >> ${envText}
  echo "ethargs=${ethArgs}" >> ${envText}
  echo "dtbcmd=${dtbCmd}" >> ${envText}
  echo "stderr=${stdioCfg}" >> ${envText}
  echo "stdin=${stdioCfg}" >> ${envText}
  echo "stdout=${stdioCfg}" >> ${envText}
  echo "blkdevpartcmd=${blkdevpartCmd}" >> ${envText}
  echo 'bootcmd=run ethargs; run blkdevpartcmd; run ainitcmd' >> ${envText}
  echo
  echo "MMC U-boot environment:"
  cat ${envText}
  ${ubootPrebuiltDir}/mkenvimage -s ${envSize} -o ${envBin} ${envText}
  sudo dd if=${envBin} of=${device} obs=${bs_uBootEnv} seek=${seek_uBootEnv}
}

burn_uboot()
{
  # install MMC u-boot
  sudo dd if=${ubootPrebuiltDir}/mmc/u-boot-spl.bin of=${device} obs=${bs_uBootSPL} seek=${seek_uBootSPL}
  sudo dd if=${ubootPrebuiltDir}/mmc/u-boot.img of=${device} obs=${bs_uBootImg} seek=${seek_uBootImg}
  burn_uboot_env
}

burn_android_images()
{
  # copy Android boot image
  sudo cp -v ${bootImg} ${sdMount}/

  # copy Android recovery image
  sudo cp -v ${recoveryImg} ${sdMount}/

  # copy kernel device tree blob
  sudo cp -v ${dtb} ${sdMount}/jz4780.dtb

  echo
  echo "Please wait, writing system.img"
  sudo dd if=${systemImg} of=${partSystem}

  echo
  echo "Please wait, writing vendor.img"
  sudo dd if=${vendorImg} of=${partVendor}
}

verify_burned_segment()
{
  originalChecksum=`md5sum $1 | awk '{print $1}'`
  copiedChecksum=`sudo md5sum $2 | awk '{print $1}'`
  if [ "$originalChecksum" != "$copiedChecksum" ]; then
    die "Burned data mismatch. $1 md5sum does not match md5sum of $2"
  fi
}

verify_burned_sd_card()
{
  sync

  local bs_verify=1
  local skip_uBootSPL=$((${bs_uBootSPL} * ${seek_uBootSPL}))
  local ubootSPLSize=$(stat -c%s ${ubootPrebuiltDir}/mmc/u-boot-spl.bin)
  sudo dd if=${device} of=${verifyDir}/u-boot-spl.bin bs=${bs_verify} skip=${skip_uBootSPL} count=${ubootSPLSize}
  verify_burned_segment ${ubootPrebuiltDir}/mmc/u-boot-spl.bin ${verifyDir}/u-boot-spl.bin

  local ubootImageSize=$(stat -c%s ${ubootPrebuiltDir}/mmc/u-boot.img)
  local skip_uBootImg=$((${bs_uBootImg} * ${seek_uBootImg}))
  sudo dd if=${device} of=${verifyDir}/u-boot.img bs=${bs_verify} skip=${skip_uBootImg} count=${ubootImageSize}
  verify_burned_segment ${ubootPrebuiltDir}/mmc/u-boot.img ${verifyDir}/u-boot.img

  local skip_uBootEnv=$((${bs_uBootEnv} * ${seek_uBootEnv}))
  sudo dd if=${device} of=${verifyDir}/ubootEnv bs=${bs_verify} skip=${skip_uBootEnv} count=${envSize}
  verify_burned_segment ${envBin} ${verifyDir}/ubootEnv

  verify_burned_segment ${bootImg} ${sdMount}/boot.img
  verify_burned_segment ${recoveryImg} ${sdMount}/recovery.img
  verify_burned_segment ${systemImg} ${partSystem}
  verify_burned_segment ${vendorImg} ${partVendor}
  verify_burned_segment ${dtb} ${sdMount}/jz4780.dtb

  echo "Successfully verified SD card content"
}

init_core $1
init_constants

configure_sd_card_partitions

burn_android_images
burn_uboot

verify_burned_sd_card
finished=true
echo
echo "Finished, wait for clean up before removing your card!"
