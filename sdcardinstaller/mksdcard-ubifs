#!/bin/bash
#
# Copyright (c) 2013,2014,2017 Imagination Technologies
# Original-Author: Paul Burton <paul.burton@imgtec.com>
#
# Creates an SD card which writes u-boot and Android filesystems to the CI20 NAND flash.
# Derived from the Debian setup script by Paul Burton
#
# Usage:
#   ./mksdcard /dev/sdX
#

set -e

cleanup()
{
  echo "Cleaning up..."
  [ -z "${sdMount}" ] || sudo umount ${sdMount}
  rm -rf ${tmpDir}
  rm -rf ${verifyDir}
  [ "${finished}" = "true" ] && sudo eject ${device} && echo "Cleanup completed; it is safe to remove your card"
  trap - EXIT INT TERM
}
trap cleanup EXIT INT TERM

die()
{
  echo "$@" >&2
  exit 1
}

sfdisk_ci20()
{
  sfdisk_tool=`which sfdisk`
  blockdev_tool=`which blockdev`
  partprobe_tool=`which partprobe`

  [ -f "$sfdisk_tool" ] || die "No sfdisk in \$PATH"
  [ -f "$blockdev_tool" ] || die "No blockdev in \$PATH"
  [ -f "$partprobe_tool" ] || die "No partprobe in \$PATH"
  [ -b "$1" ] || die "Device '$1' not found"

  sfdisk_version=`$sfdisk_tool --version | sed 's,.*2\.\([0-9]*\)\.[0-9]*,\1,'`

  unset sfdisk_is_ancient
  test $sfdisk_version -lt 26 && sfdisk_is_ancient=1

  sfdisk_dev="$1"
  shift

  sfdisk_parts=`echo $* | tr ' ' '\n'`

  set +e
  if [ $sfdisk_is_ancient ]; then
      echo "$sfdisk_parts" | tr -d M | sudo $sfdisk_tool -L -uM "$sfdisk_dev"
  else
      echo "$sfdisk_parts" | sudo $sfdisk_tool "$sfdisk_dev"
  fi
  set -e

  sudo $blockdev_tool --rereadpt $sfdisk_dev
  sudo $partprobe_tool $sfdisk_dev
  sleep 2
}

init_core()
{
  readonly tmpDir=`mktemp -d`
  readonly verifyDir=`mktemp -d`
  readonly ubootPrebuiltDir="$ANDROID_BUILD_TOP/device/imgtec/ci20/u-boot"
  #check for U-Boot prebuilt dir
  [ ! -z "${ANDROID_BUILD_TOP}" ] || die "ANDROID_BUILD_TOP has not been initialized"
  [ -e "${ubootPrebuiltDir}" ] || die "U-Boot prebuilt directory '${ubootPrebuiltDir}' does not exist"

  readonly device="$1"
  # check device
  [ -e "${device}" ] || die "Device '${device}' not found"
  grep ${device} /etc/mtab >/dev/null && \
  die "Device '${device}' contains mounted partitions"

  # Check for awk
  [ -z `which awk 2>&1` ] && die "No 'awk' present"

  # Check for bc
  [ -z `which bc 2>&1` ] && die "No 'bc' present"

  # Check for md5sum
  [ -z `which md5sum 2>&1` ] && die "No 'md5sum' present"

  # Check for mkfs.ext4
  [ -z `which mkfs.ext4 2>&1` ] && die "No 'mkfs.ext4' present"

  # Check for stat
  [ -z `which stat 2>&1` ] && die "No 'stat' present"

  return 0
}

init_partition_layout_constants()
{
  readonly partName="CI20_Android"
  # Partition sizes and offsets represent size in MB
  # Limit partition size to 1GB (U-Boot seems to have problems with large (>[24]GB?) filesystems
  readonly partSize=1024
  # 2M is skipped and used for storing U-Boot outside the visible partition layout
  readonly partOffset="2"

  readonly partitionLayout="${partOffset}M,${partSize}M"

  readonly bootVolSize="0x1600000"             #22M
  readonly recoveryVolSize="0x1600000"         #22M
  readonly cacheVolSize="0x10000000"           #256M
  readonly userdataVolSize="0x100000000"       #4G

  local ubifsScale="64 / 100"
  local systemImgEXT4Size=`stat -c %s ${systemImgEXT4}`
  local systemVolSizeDec=$((${systemImgEXT4Size} * ${ubifsScale}))
  readonly systemVolSize=`echo "ibase=10; obase=16; ${systemVolSizeDec}" | bc`
}

convert_system_image()
{
  if [[ ! -f $systemImg || "$systemImg" -ot "$systemImgEXT4" ]]; then
    echo "Converting the image to UBIFS"
    sh $ANDROID_BUILD_TOP/device/imgtec/ci20/sdcardinstaller/convert_extfs_to_ubifs $systemImgEXT4 $systemImg
    echo "CI20 specific target system fs done"
  fi

  # Check that systemImg is a ubifs
  # FIXME: unfortunately file(1) is not very helpful...
  file -b "${systemImg}" | grep -q '^data$' || \
      die "File '${systemImg}' is not a UBI filesystem image"
}

init_image_constants()
{
  # check for Android images
  readonly bootImg=${BOOTIMG:-${OUT}/boot.img}
  [ -e "${bootImg}" ] || die "Android boot image '${bootImg}' not found"
  readonly recoveryImg=${RECOVERYIMG:-${OUT}/recovery.img}
  [ -e "${recoveryImg}" ] || die "Android recovery image '${recoveryImg}' not found"
  readonly systemImgEXT4=${SYSTEMIMG:-${OUT}/system.img}
  [ -e "${systemImgEXT4}" ] || die "Android system image '${systemImgEXT4}' not found"
  readonly systemImg=${OUT}/system.ubifs.img

  local bootImgSize=`stat -c %s ${bootImg}`
  readonly bootImgSizeHex=`echo "ibase=10; obase=16; ${bootImgSize}" | bc`

  local recoveryImgSize=`stat -c %s ${recoveryImg}`
  readonly recoveryImgSizeHex=`echo "ibase=10; obase=16; ${recoveryImgSize}" | bc`

  # Size of NAND U-Boot image
  local ubootImgSize=`stat -c %s ${ubootPrebuiltDir}/nand/u-boot.img`
  readonly ubootImgSizeHex=`echo "ibase=10; obase=16; ${ubootImgSize}" | bc`

  # copy Android system image
  # FIXME: copy is done below during MMC environment generation
  # We could copy the system image in one chunk but it would make
  # the installation less verbose
  convert_system_image
  readonly systemImgSize=`stat -c %s ${systemImg}`
  readonly systemImgSizeHex=`echo "ibase=10; obase=16; ${systemImgSize}" | bc`

  readonly envSize=$((32 * 1024))

  readonly bs_uBootSPL=512
  readonly seek_uBootSPL=1
  readonly bs_uBootImg=1024
  readonly seek_uBootImg=14
  readonly bs_uBootEnv=1
  readonly seek_uBootEnv=$((526 * 1024))

  readonly envText=${tmpDir}/u-boot-env.txt
  readonly envBin=${tmpDir}/u-boot-env.bin
  readonly envBinNAND=${verifyDir}/u-boot-env-nand.bin

  readonly maxBlock=$((128 * 1024 * 1024))
}

init_uboot_env_constants()
{
  readonly mmcPart="mmc 0:1"
  readonly bootImgAddr="0x88000000"
  readonly baudRate=115200
  readonly stdioCfg="eserial0,eserial4"

  # Command to boot Android from NAND
  readonly androidBootCmd="mtdparts default; ubi part boot; ubi read ${bootImgAddr} boot ${bootImgSizeHex}; boota ${bootImgAddr}"
  # Command to set device specific MAC address
  readonly ethArgs='env set bootargs dm9000.mac_addr=${ethaddr}'

  # Commands for changing the LED color
  readonly blueLED="mw.l 0xb0010548 0x8000"
  readonly redLED="mw.l 0xb0010544 0x8000"

  # Address used for copying files from NAND or MMC and accessing it later
  readonly lsMemAddr="0x80000000"

  # Addresses used for storing U-Boot related files to NAND
  readonly splNANDAddr=8
  readonly ubootImageNANDAddr="0x800000"
  readonly ubootEnvNANDAddr="0x00a00000"
}

init_constants()
{
  init_image_constants
  init_partition_layout_constants
  init_uboot_env_constants
}

configure_sd_card_partitions()
{
  # partition SD/MMC card
  # FIXME: sfdisk often fails to reread the partition information
  sfdisk_ci20 ${device} ${partitionLayout}

  # create ext4 partition
  sudo mkfs.ext4 -L "${partName}" ${device}1

  # sdMount is not initialized in init_constants()
  # the way it is used in the cleanup() function
  readonly sdMount=${tmpDir}/sd_mount
  mkdir ${sdMount}
  # mount ext4 partition
  sudo mount ${device}1 ${sdMount}
  sudo chmod a+w ${sdMount}
}

burn_nand_uboot_env()
{
  echo "abootcmd=${androidBootCmd}" > ${envText}
  echo "bootcmd=run ethargs; run abootcmd" >> ${envText}
  echo "baudrate=${baudRate}" >> ${envText}
  echo "ethargs=${ethArgs}" >> ${envText}
  echo "stderr=${stdioCfg}" >> ${envText}
  echo "stdin=${stdioCfg}" >> ${envText}
  echo "stdout=${stdioCfg}" >> ${envText}

  echo
  echo "NAND U-boot environment:"
  cat ${envText}
  ${ubootPrebuiltDir}/mkenvimage -s ${envSize} -o ${envBin} ${envText}
  sudo cp ${envBin} ${sdMount}/u-boot-env.bin
  cp ${envBin} ${envBinNAND}

  # Delete the file so that NAND U-Boot environment configuration
  # does not get mixed with MMC U-Boot environment configuration
  rm ${envText}
}

burn_nand_uboot()
{
  # copy NAND u-boot
  sudo cp -v ${ubootPrebuiltDir}/nand/u-boot-spl.bin ${sdMount}/
  sudo cp -v ${ubootPrebuiltDir}/nand/u-boot.img ${sdMount}/
  burn_nand_uboot_env
}

burn_system_image()
{
  local idx=0
  local remaining=${systemImgSize}
  while [ ${remaining} -gt 0 ]; do
    local currSize=${remaining}
    [ ${currSize} -le ${maxBlock} ] || currSize=${maxBlock}
    local currSizeHex=`echo "ibase=10; obase=16; ${currSize}" | bc`
    local currFile="system.ubifs.${idx}"
    echo "Please wait, writing ${currFile}"
    sudo dd if=${systemImg} of=${sdMount}/${currFile} \
      bs=${maxBlock} skip=${idx} count=1
    sync
    local fullSize=""
    [ ${idx} -gt 0 ] || fullSize="${systemImgSizeHex}"
    local flashCmd="ext4load ${mmcPart} ${lsMemAddr} ${currFile};"
    flashCmd="${flashCmd} ubi write.part ${lsMemAddr} system ${currSizeHex} ${fullSize};"
    flashCmd="${flashCmd} run flash_system$((${idx} + 1))"
    echo "flash_system${idx}=${flashCmd}" >> ${envText}
    idx=$((${idx} + 1))
    remaining=$((${remaining} - ${currSize}))
  done
  echo "flash_system${idx}=${redLED}; echo All done :)" >> ${envText}
}

burn_android_images()
{
  # copy Android boot image
  sudo cp -v ${bootImg} ${sdMount}/

  # copy Android recovery image
  sudo cp -v ${recoveryImg} ${sdMount}/

  burn_system_image
}

burn_mmc_uboot_env()
{
  # generate (SD/MMC) u-boot environment
  androidInitCmd="${blueLED}; \
  nand erase.chip; \
  ext4load ${mmcPart} ${lsMemAddr} u-boot-spl.bin; \
  writespl ${lsMemAddr} ${splNANDAddr}; \
  mtdparts default; \
  ext4load ${mmcPart} ${lsMemAddr} u-boot.img; \
  nand write ${lsMemAddr} ${ubootImageNANDAddr} ${ubootImgSizeHex}; \
  ext4load ${mmcPart} ${lsMemAddr} u-boot-env.bin; \
  nand write ${lsMemAddr} ${ubootEnvNANDAddr} ${envSize}; \
  ubi part boot; \
  ubi create boot ${bootVolSize}; \
  ubi create recovery ${recoveryVolSize}; \
  ext4load ${mmcPart} ${lsMemAddr} boot.img; \
  ubi write ${lsMemAddr} boot ${bootImgSizeHex}; \
  ext4load ${mmcPart} ${lsMemAddr} recovery.img; \
  ubi write ${lsMemAddr} recovery ${recoveryImgSizeHex}; \
  ubi part system; \
  ubi create system ${systemVolSize}; \
  ubi create cache ${cacheVolSize}; \
  ubi create userdata ${userdataVolSize}; \
  run flash_system0"

  echo "abootcmd=${androidBootCmd}" >> ${envText}
  echo "ainitcmd=${androidInitCmd}" >> ${envText}
  echo "baudrate=${baudRate}" >> ${envText}
  echo "stderr=${stdioCfg}" >> ${envText}
  echo "stdin=${stdioCfg}" >> ${envText}
  echo "stdout=${stdioCfg}" >> ${envText}
  echo "bootcmd=run ainitcmd" >> ${envText}

  echo
  echo "MMC U-boot environment:"
  cat ${envText}
  ${ubootPrebuiltDir}/mkenvimage -s ${envSize} -o ${envBin} ${envText}
  sudo dd if=${envBin} of=${device} obs=${bs_uBootEnv} seek=${seek_uBootEnv}
}

burn_mmc_uboot()
{
  # install MMC u-boot
  sudo dd if=${ubootPrebuiltDir}/mmc/u-boot-spl.bin of=${device} obs=${bs_uBootSPL} seek=${seek_uBootSPL}
  sudo dd if=${ubootPrebuiltDir}/mmc/u-boot.img of=${device} obs=${bs_uBootImg} seek=${seek_uBootImg}
  burn_mmc_uboot_env
}

verify_burned_segment()
{
  originalChecksum=`md5sum $1 | awk '{print $1}'`
  copiedChecksum=`sudo md5sum $2 | awk '{print $1}'`
  if [ "$originalChecksum" != "$copiedChecksum" ]; then
    die "Burned data mismatch. $1 md5sum does not match md5sum of $2"
  fi
}

verify_burned_sd_card()
{
  sync

  local bs_verify=1
  local skip_uBootSPL=$((${bs_uBootSPL} * ${seek_uBootSPL}))
  local ubootSPLSize=$(stat -c%s ${ubootPrebuiltDir}/mmc/u-boot-spl.bin)
  sudo dd if=${device} of=${verifyDir}/u-boot-spl.bin bs=${bs_verify} skip=${skip_uBootSPL} count=${ubootSPLSize}
  verify_burned_segment ${ubootPrebuiltDir}/mmc/u-boot-spl.bin ${verifyDir}/u-boot-spl.bin

  local ubootImageSize=$(stat -c%s ${ubootPrebuiltDir}/mmc/u-boot.img)
  local skip_uBootImg=$((${bs_uBootImg} * ${seek_uBootImg}))
  sudo dd if=${device} of=${verifyDir}/u-boot.img bs=${bs_verify} skip=${skip_uBootImg} count=${ubootImageSize}
  verify_burned_segment ${ubootPrebuiltDir}/mmc/u-boot.img ${verifyDir}/u-boot.img

  local skip_uBootEnv=$((${bs_uBootEnv} * ${seek_uBootEnv}))
  sudo dd if=${device} of=${verifyDir}/ubootEnv bs=${bs_verify} skip=${skip_uBootEnv} count=${envSize}
  verify_burned_segment ${envBin} ${verifyDir}/ubootEnv

  verify_burned_segment ${ubootPrebuiltDir}/nand/u-boot-spl.bin ${sdMount}/u-boot-spl.bin
  verify_burned_segment ${ubootPrebuiltDir}/nand/u-boot.img ${sdMount}/u-boot.img
  verify_burned_segment ${bootImg} ${sdMount}/boot.img
  verify_burned_segment ${recoveryImg} ${sdMount}/recovery.img
  verify_burned_segment ${envBinNAND} ${sdMount}/u-boot-env.bin

  local idx=0
  local remaining=${systemImgSize}
  while [ ${remaining} -gt 0 ]; do
    local currSize=${remaining}
    [ ${currSize} -le ${maxBlock} ] || currSize=${maxBlock}
    local currFile="system.ubifs.${idx}"
    dd if=${systemImg} of=${verifyDir}/${currFile} \
      bs=${maxBlock} skip=${idx} count=1
    verify_burned_segment ${verifyDir}/${currFile} ${sdMount}/${currFile}
    idx=$((${idx} + 1))
    remaining=$((${remaining} - ${currSize}))
  done

  echo "Successfully verified SD card content"
}

init_core $1
init_constants

configure_sd_card_partitions

burn_nand_uboot
burn_android_images
burn_mmc_uboot

echo
echo "SD contents:"
ls -hl ${sdMount}/

verify_burned_sd_card
finished=true
echo
echo "Finished, wait for clean up before removing your card!"
